<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Französisch-Verben-Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Lighter blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure it takes full viewport height */
            padding: 1.5rem; /* Increased overall padding */
        }
        .container {
            max-width: 768px; /* Reduced max-width for a less wide horizontal feel */
            width: 100%; /* Ensure it takes full width on smaller screens */
        }
        .card {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.05); /* Stronger shadow */
            padding: 2.5rem; /* Increased padding */
        }
        /* Style for multi-select dropdowns */
        .filter-select[multiple] {
            height: auto;
            min-height: 120px;
            padding: 0.75rem;
            border: 1px solid #cbd5e0; /* Light gray border */
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
            transition: all 0.2s ease-in-out;
        }
        .filter-select[multiple]:focus {
            outline: none;
            border-color: #6366f1; /* Indigo-500 on focus */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); /* Focus ring */
        }
        .filter-select[multiple]::-ms-expand {
            display: none;
        }
        .filter-select[multiple] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none;
            padding-right: 0.75rem;
        }

        /* Button Styling */
        .btn {
            font-weight: 700; /* Bold font */
            padding: 0.75rem 1.5rem; /* Increased padding */
            border-radius: 0.75rem; /* More rounded */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Indigo-700 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-success {
            background-color: #22c55e; /* Green-500 */
            color: white;
        }
        .btn-success:hover {
            background-color: #16a34a; /* Green-600 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red-500 */
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Red-600 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Gray-200 */
            color: #374151; /* Gray-700 */
        }
        .btn-secondary:hover {
            background-color: #d1d5db; /* Gray-300 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5; /* Indigo for spinner */
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .irregularity-tag {
            display: inline-block;
            padding: 0.25rem 0.6rem; /* Slightly more padding */
            margin: 0.25rem;
            border-radius: 0.75rem; /* More rounded pill shape */
            font-size: 0.7rem; /* Slightly smaller font */
            font-weight: 600;
            color: #ffffff;
            background-color: #f97316; /* Orange-500 for irregularities */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
        }
        /* Removed .pronunciation-button styles as the button is removed */

        .feedback-message {
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            font-size: 1.25rem; /* Larger font */
            font-weight: 700; /* Bolder */
        }
        .feedback-correct {
            background-color: #dcfce7; /* Green-100 */
            color: #16a34a; /* Green-600 */
        }
        .feedback-almost {
            background-color: #ffedd5; /* Orange-100 */
            color: #ea580c; /* Orange-700 */
        }
        .feedback-wrong {
            background-color: #fee2e2; /* Red-100 */
            color: #dc2626; /* Red-600 */
        }
        .feedback-info {
            background-color: #e0f2fe; /* Blue-100 */
            color: #2563eb; /* Blue-600 */
        }
        .modal-box {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            background-color: #60a5fa; /* Blue-400 */
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .info-icon:hover {
            background-color: #3b82f6; /* Blue-500 */
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280; /* Gray-500 */
        }
        .modal-close-btn:hover {
            color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="p-4">
    <div class="container mx-auto mt-8 card">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-6">Französisch-Verben-Quiz</h1>
        <p class="text-center text-gray-600 mb-8">
            Teste dein Wissen über französische Verbkonjugationen!
        </p>

        <div id="quizSetupScreen" class="">
            <h2 class="text-2xl font-bold text-gray-700 mb-4">Quiz-Einstellungen</h2>
            <div class="flex flex-col md:flex-row justify-center items-start gap-6 mb-8">
                <div class="w-full md:w-1/2">
                    <label for="tenseFilter" class="block text-gray-700 text-sm font-bold mb-2">Wähle Zeitform(en):</label>
                    <select id="tenseFilter" multiple size="4" class="filter-select block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 ease-in-out">
                        <option value="present">Présent</option>
                        <option value="imparfait">Imparfait</option>
                        <option value="passe_compose">Passé Composé</option>
                    </select>
                </div>

                <div class="w-full md:w-1/2">
                    <label for="pronounFilter" class="block text-gray-700 text-sm font-bold mb-2">Wähle Pronomen:</label>
                    <select id="pronounFilter" multiple size="6" class="filter-select block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 ease-in-out">
                        <option value="je">Je</option>
                        <option value="tu">Tu</option>
                        <option value="il">Il/Elle/On</option>
                        <option value="nous">Nous</option>
                        <option value="vous">Vous</option>
                        <option value="ils">Ils/Elles</option>
                    </select>
                </div>
            </div>

            <div class="mb-6">
                <label for="seedInput" class="block text-gray-700 text-sm font-bold mb-2">
                    Seed für Verbengruppen (optional):
                    <span id="infoIcon" class="info-icon" title="Zeigt die Verben in der aktuellen Lerngruppe an.">i</span>
                </label>
                <div class="flex items-center">
                    <input type="text" id="seedInput" class="flex-grow p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-lg transition duration-200 ease-in-out" placeholder="Gib hier einen Seed ein oder lasse es leer">
                    <button id="changeSeedBtn" class="btn btn-secondary ml-2 px-4 py-3 text-sm">Seed ändern</button>
                </div>
                <p class="text-sm text-gray-500 mt-2">
                    Aktueller Seed: <span id="currentSeedDisplay" class="font-semibold text-gray-700"></span>
                    <br>
                    <span class="text-xs text-gray-400">Gib einen neuen Seed oben ein und klicke auf "Seed ändern", um die Verbengruppen neu zu generieren.</span>
                </p>
            </div>


            <div id="setupFeedback" class="text-center text-xl font-bold mb-6"></div>

            <button id="startQuizBtn" class="btn btn-success w-full mb-6">Quiz starten</button>

            <div id="progressDisplay" class="bg-gray-100 p-6 rounded-lg text-gray-700 shadow-inner">
                <h3 class="text-xl font-semibold mb-3">Dein Fortschritt:</h3>
                <p class="mb-1">Insgesamt beantwortete Fragen: <span id="totalAnswered" class="font-bold text-gray-900">0</span></p>
                <p class="mb-1">Richtige Antworten: <span id="correctAnswers" class="font-bold text-green-600">0</span></p>
                <p class="mb-1">Zu wiederholende Verben: <span id="verbsToReview" class="font-bold text-red-500">0</span></p>
                <p>Studienzeit: <span id="studyTime" class="font-bold text-gray-900">0m 0s</span></p>
                <button id="clearProgressBtn" class="btn btn-danger mt-6">Fortschritt löschen</button>
            </div>
        </div>

        <div id="quizScreen" class="hidden">
            <h2 class="text-2xl font-bold text-gray-700 mb-4">Quiz läuft</h2>
            <div class="bg-blue-50 p-8 rounded-lg text-center mb-6 shadow-md">
                <p class="text-xl text-gray-600 mb-2">Infinitiv:</p>
                <p id="quizInfinitive" class="text-4xl font-extrabold text-blue-800 mb-6"></p>
                <p class="text-lg text-gray-600 mb-2">Zeitform:</p>
                <p id="quizTense" class="text-2xl font-semibold text-blue-700 mb-4"></p>
            </div>

            <div class="w-full bg-gray-200 rounded-full h-4 mb-6">
                <div id="progressBar" class="bg-blue-600 h-4 rounded-full text-xs flex items-center justify-center text-white" style="width: 0%;">
                    <span id="progressBarText">0%</span>
                </div>
            </div>

            <div class="flex flex-col items-center justify-center gap-4 mb-6">
                <div class="flex items-center w-full max-w-sm">
                    <span id="quizPronounPrefix" class="text-2xl font-semibold text-blue-700 mr-2 min-w-[5rem] text-right"></span>
                    <input type="text" id="answerInput" class="flex-grow p-3 border-2 border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-lg transition duration-200 ease-in-out" placeholder="Gib deine Konjugation hier ein">
                </div>
            </div>

            <div id="feedback" class="text-center feedback-message"></div>

            <div class="flex justify-center gap-4 mt-6">
                <button id="checkAnswerBtn" class="btn btn-primary">Antwort prüfen</button>
                <button id="nextVerbBtn" class="btn btn-secondary hidden">Nächstes Verb</button>
            </div>
        </div>
    </div>

    <div id="verbGroupInfoModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="closeVerbGroupInfoModal">&times;</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Verben in der aktuellen Gruppe</h3>
            <ul id="verbList" class="list-disc list-inside text-left text-gray-700">
                </ul>
            <p class="text-sm text-gray-600 mt-4">
                Ein Verb gilt als gemeistert, wenn es <span class="font-bold">${REQUIRED_MASTERY_COUNT}</span> Mal richtig beantwortet wurde.
            </p>
        </div>
    </div>

    <script>
        let verbsData = []; // This will store the data fetched from verbs.json
        let quizVerbs = []; // This will now store all questions for the current quiz session
        let currentVerbIndex = 0; // Tracks the current question within the quizVerbs array
        let currentQuizSessionQuestionsAnswered = 0; // Tracks questions answered in the current session
        let currentQuestion = {}; // Stores the current verb, tense, and pronoun for the question
        let quizProgress = {}; // Stores user progress for each conjugation (correct/incorrect counts)
        let studyTimeSeconds = 0; // Total accumulated study time in seconds
        let timerInterval = null; // Holds the setInterval ID for the timer

        // New state for learning algorithm
        let learningState = {
            verbGroups: [], // Array of arrays of verb infinitives (randomly assigned)
            currentLearningGroupIndex: 0, // Index of the current group being learned
            seed: null // The seed used to generate verb groups
        };

        const GROUP_SIZE = 15; // Number of verbs per learning group
        const SESSION_TOTAL_QUESTIONS = 20; // Total questions in one quiz session
        const REQUIRED_MASTERY_COUNT = 5; // Number of correct answers needed to consider a conjugation "learned" for group advancement
        const NEXT_GROUP_MIX_START_PERCENTAGE = 0.5; // Start mixing next group verbs when current group is 50% done
        const NEXT_GROUP_MIX_END_PERCENTAGE = 0.9; // Max mixing of next group verbs when current group is 90% done
        const REVIEW_PREVIOUS_GROUP_CHANCE = 0.2; // Constant chance to pull from previous groups (20%)

        // Global seeded random instance
        let seededRand = null;

        class SeededRandom {
            constructor(seed) {
                // Ensure seed is a number and positive for the LCG
                this.seed = typeof seed === 'string' ? seed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) : seed;
                this.seed = this.seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }

            next() {
                // Linear Congruential Generator parameters (a, c, m)
                // m = 2^31 - 1 (a common prime modulus)
                // a = 1103515245, c = 12345
                this.seed = (this.seed * 1103515245 + 12345) % 2147483647;
                return this.seed / 2147483647; // Return a float between 0 and 1
            }

            // Fisher-Yates shuffle using this PRNG
            shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(this.next() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
        }


        // Get references to DOM elements
        const quizSetupScreen = document.getElementById('quizSetupScreen');
        const quizScreen = document.getElementById('quizScreen');
        const tenseFilter = document.getElementById('tenseFilter');
        const pronounFilter = document.getElementById('pronounFilter');
        const startQuizBtn = document.getElementById('startQuizBtn');
        const setupFeedbackDiv = document.getElementById('setupFeedback'); // Feedback div for setup screen

        const quizInfinitive = document.getElementById('quizInfinitive');
        const quizTense = document.getElementById('quizTense');
        const quizPronounPrefix = document.getElementById('quizPronounPrefix'); // New element for pronoun prefix
        const answerInput = document.getElementById('answerInput');
        const feedbackDiv = document.getElementById('feedback'); // Feedback div for quiz screen
        const checkAnswerBtn = document.getElementById('checkAnswerBtn');
        const nextVerbBtn = document.getElementById('nextVerbBtn');

        const progressBar = document.getElementById('progressBar'); // Progress bar element
        const progressBarText = document.getElementById('progressBarText'); // Text inside progress bar

        const totalAnsweredSpan = document.getElementById('totalAnswered');
        const correctAnswersSpan = document.getElementById('correctAnswers');
        const verbsToReviewSpan = document.getElementById('verbsToReview');
        const studyTimeSpan = document.getElementById('studyTime'); // New study time span
        const clearProgressBtn = document.getElementById('clearProgressBtn');

        const seedInput = document.getElementById('seedInput'); // New seed input field
        const currentSeedDisplay = document.getElementById('currentSeedDisplay'); // New element to display current seed
        const changeSeedBtn = document.getElementById('changeSeedBtn'); // New button to change seed

        // New elements for the modal
        const infoIcon = document.getElementById('infoIcon');
        const verbGroupInfoModal = document.getElementById('verbGroupInfoModal');
        const closeVerbGroupInfoModalBtn = document.getElementById('closeVerbGroupInfoModal');
        const verbListUl = document.getElementById('verbList');

        // Global variable to store the French voice for Web Speech API
        let frenchVoice = null;

        // --- Utility Functions ---

        /**
         * Formats the tense key for display.
         * @param {string} key - The tense key (e.g., 'passe_compose').
         * @returns {string} The formatted tense name (e.g., 'Passé Composé').
         */
        function formatTenseName(key) {
            switch (key) {
                case 'present': return 'Présent';
                case 'imparfait': return 'Imparfait';
                case 'passe_compose': return 'Passé Composé';
                default: return key;
            }
        }

        /**
         * Formats the pronoun key for display.
         * @param {string} key - The pronoun key (e.g., 'il').
         * @returns {string} The formatted pronoun (e.g., 'Il/Elle/On').
         */
        function formatPronoun(key) {
            switch (key) {
                case 'je': return 'Je';
                case 'tu': return 'Tu';
                case 'il': return 'Il/Elle/On';
                case 'nous': return 'Nous';
                case 'vous': return 'Vous';
                case 'ils': return 'Ils/Elles';
                default: return key;
            }
        }

        /**
         * Returns the single pronoun for construction (e.g., 'il' for 'il/elle/on').
         * Used for constructing the full conjugated phrase.
         * @param {string} key - The pronoun key (e.g., 'il').
         * @returns {string} The single pronoun string.
         */
        function getSinglePronounForConstruction(key) {
            switch (key) {
                case 'je': return 'je';
                case 'tu': return 'tu';
                case 'il': return 'il';
                case 'nous': return 'nous';
                case 'vous': return 'vous';
                case 'ils': return 'ils';
                default: return key;
            }
        }

        /**
         * Constructs the full conjugated phrase (pronoun + verb) for display/pronunciation.
         * Handles contractions like j' and reflexive verbs.
         * @param {string} pronounKey - The internal pronoun key (e.g., 'je', 'il').
         * @param {string} conjugation - The conjugated verb form (e.g., 'ai', 'suis allé(e)').
         * @param {string} infinitive - The infinitive of the current verb (to check for impersonal/reflexive).
         * @returns {string} The full conjugated phrase (e.g., 'j'ai', 'il mange', 'nous nous levons').
         */
        function getFullConjugatedPhrase(pronounKey, conjugation, infinitive) {
            // Special handling for impersonal verbs (falloir, pleuvoir) which don't use a pronoun in the phrase
            if (infinitive === "falloir" || infinitive === "pleuvoir") {
                return conjugation;
            }

            // Check if the verb is reflexive based on its infinitive (starts with "s'")
            const isReflexiveVerb = infinitive.startsWith("s'");

            // If it's a reflexive verb, the conjugation already contains the reflexive pronoun.
            // Just return the conjugation as is.
            if (isReflexiveVerb) {
                return conjugation;
            }

            // Handle 'je' contraction for verbs starting with a vowel or silent 'h'
            const firstLetterOfConjugation = conjugation.charAt(0).toLowerCase();
            const isVowelOrSilentH = ['a', 'e', 'i', 'o', 'u', 'h'].includes(firstLetterOfConjugation);

            if (pronounKey === 'je' && isVowelOrSilentH) {
                return `j'${conjugation}`;
            }

            // For all other cases, prepend the standard pronoun and a space
            return `${getSinglePronounForConstruction(pronounKey)} ${conjugation}`;
        }

        /**
         * Calculates the Levenshtein distance between two strings.
         * Used for "almost" correct checking.
         * @param {string} s1 - First string.
         * @param {string} s2 - Second string.
         * @returns {number} The Levenshtein distance.
         */
        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(newValue, lastValue, costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) {
                    costs[s2.length] = lastValue;
                }
            }
            return costs[s2.length];
        }

        // --- Learning Algorithm & Quiz Logic ---

        /**
         * Initializes verb groups. Can force re-initialization with a specific seed.
         * @param {string|number} [forceSeed=null] - Optional seed to force re-initialization.
         */
        function initializeVerbGroups(forceSeed = null) {
            let storedVerbGroups = localStorage.getItem('verbGroups');
            let storedCurrentGroupIndex = localStorage.getItem('currentLearningGroupIndex');
            let storedSeed = localStorage.getItem('learningSeed'); // New: load stored seed

            let needsReinitialization = true;
            let effectiveSeed = null;

            if (forceSeed !== null) {
                // User explicitly provided a seed, force re-initialization
                effectiveSeed = typeof forceSeed === 'string' ? forceSeed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) : forceSeed;
                console.log("Forcing re-initialization with seed:", effectiveSeed);
            } else if (storedVerbGroups && storedCurrentGroupIndex !== null && storedSeed !== null) {
                try {
                    const parsedGroups = JSON.parse(storedVerbGroups);
                    const totalVerbsInStoredGroups = parsedGroups.flat().length;
                    // Check if all verbs from verbsData are present in the parsed groups
                    const allVerbsPresent = verbsData.every(verb => parsedGroups.flat().includes(verb.infinitive));

                    // Add check for GROUP_SIZE consistency
                    const firstGroupSize = parsedGroups.length > 0 ? parsedGroups[0].length : 0;
                    const groupSizeConsistent = parsedGroups.every(group => group.length <= GROUP_SIZE); // Last group might be smaller

                    if (totalVerbsInStoredGroups === verbsData.length && allVerbsPresent && groupSizeConsistent) {
                        learningState.verbGroups = parsedGroups;
                        learningState.currentLearningGroupIndex = parseInt(storedCurrentGroupIndex, 10);
                        learningState.seed = storedSeed; // Load the seed into learningState
                        effectiveSeed = storedSeed;
                        needsReinitialization = false;
                        console.log("Loaded existing verb groups with seed:", effectiveSeed);
                    } else {
                        console.warn("Stored verb groups are inconsistent (e.g., size changed or verbs missing), re-initializing.");
                    }
                } catch (e) {
                    console.error("Error parsing stored verb groups or seed:", e);
                }
            }

            if (needsReinitialization) {
                if (effectiveSeed === null) {
                    // No forced seed, no valid stored seed, generate a new random one
                    effectiveSeed = Date.now(); // Use timestamp for a truly random-like seed
                    console.log("Generating new random seed:", effectiveSeed);
                }

                seededRand = new SeededRandom(effectiveSeed);
                learningState.seed = effectiveSeed; // Store the seed in learningState

                let allInfinitives = verbsData.map(v => v.infinitive);
                seededRand.shuffle(allInfinitives); // Use seeded shuffle

                let groups = [];
                for (let i = 0; i < allInfinitives.length; i += GROUP_SIZE) {
                    groups.push(allInfinitives.slice(i, i + GROUP_SIZE));
                }
                learningState.verbGroups = groups;
                learningState.currentLearningGroupIndex = 0; // Start with the first group
                saveLearningState(); // Save initial state
                console.log("Verb groups initialized/re-initialized.");
            } else {
                // If not re-initializing, ensure seededRand is set for subsequent shuffles (though not strictly needed for session generation)
                seededRand = new SeededRandom(effectiveSeed);
            }

            // Update the seed display in the UI
            if (currentSeedDisplay) {
                currentSeedDisplay.textContent = learningState.seed;
            }
            updateProgressDisplay(); // Update progress display after seed change
        }

        /**
         * Saves the current learning state (verb groups and current group index) to localStorage.
         */
        function saveLearningState() {
            localStorage.setItem('verbGroups', JSON.stringify(learningState.verbGroups));
            localStorage.setItem('currentLearningGroupIndex', learningState.currentLearningGroupIndex.toString());
            localStorage.setItem('learningSeed', learningState.seed.toString()); // Save the seed
        }

        /**
         * Fetches verb data from the specified URL.
         */
        async function fetchVerbsData() {
            try {
                // Use the provided URL for verbs.json
                const response = await fetch('https://maxim-mtm.github.io/frenchverbs/verbs.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                verbsData = await response.json();
                console.log("Verbs data loaded:", verbsData.length, "verbs.");
                initializeVerbGroups(); // Initialize groups after verbsData is loaded
                loadProgress(); // Load quiz progress
                updateProgressDisplay();
            } catch (error) {
                console.error('Error fetching verbs data:', error);
                if (quizSetupScreen) {
                    setupFeedbackDiv.textContent = 'Fehler beim Laden der Verben. Bitte stelle sicher, dass verbs.json unter der korrekten URL verfügbar ist.';
                    setupFeedbackDiv.classList.add('feedback-wrong');
                }
            }
        }

        /**
         * Generates the questions for the current quiz session based on the learning algorithm.
         */
        function generateQuizSessionQuestions() {
            const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
            const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);

            if (selectedTenses.length === 0 || selectedPronouns.length === 0) {
                setupFeedbackDiv.textContent = "Bitte wähle mindestens eine Zeitform und ein Pronomen, um das Quiz zu starten.";
                setupFeedbackDiv.classList.add('feedback-info');
                return [];
            }

            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            const nextGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex + 1] || [];
            let previousGroupsInfinitives = [];
            for (let i = 0; i < learningState.currentLearningGroupIndex; i++) {
                previousGroupsInfinitives = previousGroupsInfinitives.concat(learningState.verbGroups[i]);
            }

            let currentGroupQuestions = [];
            let nextGroupQuestions = [];
            let previousGroupQuestions = [];

            // Helper to generate questions from a list of infinitives
            const generateQuestionsForInfinitives = (infinitives, poolType) => {
                let questions = [];
                infinitives.forEach(infinitive => {
                    const verb = verbsData.find(v => v.infinitive === infinitive);
                    if (verb) {
                        selectedTenses.forEach(tenseKey => {
                            selectedPronouns.forEach(pronounKey => {
                                if (verb.conjugations[tenseKey] && verb.conjugations[tenseKey][pronounKey]) {
                                    questions.push({
                                        infinitive: verb.infinitive,
                                        translation: verb.translation,
                                        tense: tenseKey,
                                        pronoun: pronounKey,
                                        correctAnswer: verb.conjugations[tenseKey][pronounKey],
                                        poolType: poolType // 'current', 'next', 'previous'
                                    });
                                }
                            });
                        });
                    }
                });
                return questions;
            };

            currentGroupQuestions = generateQuestionsForInfinitives(currentGroupInfinitives, 'current');
            nextGroupQuestions = generateQuestionsForInfinitives(nextGroupInfinitives, 'next');
            previousGroupQuestions = generateQuestionsForInfinitives(previousGroupsInfinitives, 'previous');

            // Shuffle all pools independently using the seeded random
            seededRand.shuffle(currentGroupQuestions);
            seededRand.shuffle(nextGroupQuestions);
            seededRand.shuffle(previousGroupQuestions);

            let sessionQuestions = [];
            let questionsFromCurrentGroupAdded = 0; // Track how many questions from current group are added to session

            for (let i = 0; i < SESSION_TOTAL_QUESTIONS; i++) {
                // Calculate progress within the current learning group based on its actual size
                const totalConjugationsInCurrentGroup = currentGroupQuestions.length; // Total possible questions from current group based on filters
                const progressInCurrentGroup = totalConjugationsInCurrentGroup > 0 ? (questionsFromCurrentGroupAdded / totalConjugationsInCurrentGroup) : 0;

                let questionToAdd = null;
                const randomChance = seededRand.next(); // Use seeded random for decision making

                // Gradual mixing of next group verbs
                let dynamicNextGroupMixChance = 0;
                if (progressInCurrentGroup >= NEXT_GROUP_MIX_START_PERCENTAGE) {
                    dynamicNextGroupMixChance = (progressInCurrentGroup - NEXT_GROUP_MIX_START_PERCENTAGE) / (NEXT_GROUP_MIX_END_PERCENTAGE - NEXT_GROUP_MIX_START_PERCENTAGE);
                    dynamicNextGroupMixChance = Math.min(Math.max(0, dynamicNextGroupMixChance), 1); // Clamp between 0 and 1
                }

                // Prioritize current group, then previous for review, then next for gradual introduction
                if (currentGroupQuestions.length > 0 && (randomChance >= dynamicNextGroupMixChance + REVIEW_PREVIOUS_GROUP_CHANCE || nextGroupQuestions.length === 0 && previousGroupQuestions.length === 0)) {
                    questionToAdd = currentGroupQuestions.pop();
                    questionsFromCurrentGroupAdded++;
                } else if (previousGroupQuestions.length > 0 && randomChance < dynamicNextGroupMixChance + REVIEW_PREVIOUS_GROUP_CHANCE) {
                    questionToAdd = previousGroupQuestions.pop();
                } else if (nextGroupQuestions.length > 0 && randomChance < dynamicNextGroupMixChance) {
                    questionToAdd = nextGroupQuestions.pop();
                } else if (currentGroupQuestions.length > 0) { // Fallback to current group if other chances fail or pools empty
                    questionToAdd = currentGroupQuestions.pop();
                    questionsFromCurrentGroupAdded++;
                } else {
                    // If all specific pools are exhausted, try to pull from any remaining questions (e.g., if a pool was small)
                    const allRemainingQuestions = [...currentGroupQuestions, ...nextGroupQuestions, ...previousGroupQuestions].filter(q => !sessionQuestions.includes(q));
                    if (allRemainingQuestions.length > 0) {
                        questionToAdd = allRemainingQuestions.pop();
                        if (questionToAdd.poolType === 'current') {
                             questionsFromCurrentGroupAdded++;
                        }
                    } else {
                        // If no questions can be generated, break
                        break;
                    }
                }

                if (questionToAdd) {
                    sessionQuestions.push(questionToAdd);
                }
            }

            if (sessionQuestions.length === 0) {
                setupFeedbackDiv.textContent = "Keine Fragen für die ausgewählten Filter und Gruppen gefunden. Bitte wähle mehr Zeitformen oder Pronomen.";
                setupFeedbackDiv.classList.add('feedback-info');
            }

            return sessionQuestions;
        }

        /**
         * Starts the quiz session.
         */
        function startQuiz() {
            const userProvidedSeed = seedInput.value.trim();

            setupFeedbackDiv.textContent = '';
            setupFeedbackDiv.className = "text-center text-xl font-bold mb-6";

            const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
            const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);

            if (selectedTenses.length === 0 || selectedPronouns.length === 0) {
                setupFeedbackDiv.textContent = "Bitte wähle mindestens eine Zeitform und ein Pronomen, um das Quiz zu starten.";
                setupFeedbackDiv.classList.add('feedback-info');
                return;
            }

            // If user provided a seed, or if the current learning state doesn't have a seed
            // or if the provided seed is different from the current one, re-initialize groups.
            if (userProvidedSeed !== '' && userProvidedSeed !== String(learningState.seed)) { // Compare as strings
                initializeVerbGroups(userProvidedSeed); // Force re-initialization with user's seed
            } else if (learningState.seed === null || learningState.verbGroups.length === 0) {
                // If no seed was loaded (e.g., first run or cleared) or groups are empty, initialize
                initializeVerbGroups(); // Will generate a new random seed if not forced
            }
            // If a seed was loaded and user didn't change it, no re-initialization needed here.

            quizVerbs = generateQuizSessionQuestions(); // Generate all questions for the session

            if (quizVerbs.length === 0) {
                // Feedback already set by generateQuizSessionQuestions
                return;
            }

            // Shuffle the generated questions for the session using the seeded random
            seededRand.shuffle(quizVerbs);

            currentVerbIndex = 0; // Reset question index for the new session
            currentQuizSessionQuestionsAnswered = 0; // Reset session question counter

            startTimer(); // Start the study timer
            quizSetupScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');
            feedbackDiv.textContent = '';
            feedbackDiv.className = "text-center feedback-message"; // Reset class
            displayQuestion(); // Display the first question
        }

        /**
         * Displays the current quiz question.
         */
        function displayQuestion() {
            if (currentVerbIndex >= quizVerbs.length) {
                // End of quiz session (all pre-generated questions answered)
                stopTimer(); // Stop the timer when quiz finishes
                checkAndAdvanceGroup(); // Check if current group is mastered

                const messageBox = document.createElement('div');
                messageBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
                messageBox.innerHTML = `
                    <div class="modal-box">
                        <p class="text-lg font-semibold mb-4">Quiz beendet!</p>
                        <p>Du hast alle Fragen für diese Sitzung beantwortet. Zurück zum Einstellungsbildschirm.</p>
                        <button class="btn btn-primary mt-4" onclick="this.closest('.fixed').remove(); returnToSetupScreen();">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);
                return;
            }

            currentQuestion = quizVerbs[currentVerbIndex]; // Get question from pre-generated list

            updateProgressBar(); // Update progress bar for the session

            quizInfinitive.textContent = `${currentQuestion.translation}`;
            quizTense.textContent = formatTenseName(currentQuestion.tense);

            // Dynamically set quizPronounPrefix to 'J'' if applicable
            if (currentQuestion.pronoun === 'je') {
                const verb = verbsData.find(v => v.infinitive === currentQuestion.infinitive);
                if (verb) {
                    const conjugation = verb.conjugations[currentQuestion.tense][currentQuestion.pronoun];
                    const firstLetterOfConjugation = conjugation.charAt(0).toLowerCase();
                    const isVowelOrSilentH = ['a', 'e', 'i', 'o', 'u', 'h'].includes(firstLetterOfConjugation);
                    if (isVowelOrSilentH) {
                        quizPronounPrefix.textContent = `J'`;
                    } else {
                        quizPronounPrefix.textContent = formatPronoun(currentQuestion.pronoun);
                    }
                } else {
                    quizPronounPrefix.textContent = formatPronoun(currentQuestion.pronoun); // Fallback
                }
            } else {
                quizPronounPrefix.textContent = formatPronoun(currentQuestion.pronoun);
            }


            answerInput.value = '';
            feedbackDiv.textContent = '';
            feedbackDiv.className = "text-center feedback-message"; // Reset class
            checkAnswerBtn.classList.remove('hidden');
            nextVerbBtn.classList.add('hidden');
            answerInput.focus();
        }

        /**
         * Returns to the quiz setup screen.
         */
        function returnToSetupScreen() {
            stopTimer(); // Stop the timer when returning to setup screen
            quizScreen.classList.add('hidden');
            quizSetupScreen.classList.remove('hidden');
            currentVerbIndex = 0; // Reset session question counter
            currentQuizSessionQuestionsAnswered = 0; // Reset session question counter
            quizVerbs = []; // Clear quiz verbs for next session
            updateProgressDisplay(); // Update progress display on return
        }

        /**
         * Checks the user's answer.
         */
        function checkAnswer() {
            const userAnswer = answerInput.value.trim();
            const correctConjugation = currentQuestion.correctAnswer.trim();
            const questionKey = `${currentQuestion.infinitive}-${currentQuestion.tense}-${currentQuestion.pronoun}`;

            // Initialize progress for this question if it doesn't exist
            if (!quizProgress[questionKey]) {
                quizProgress[questionKey] = { correct: 0, incorrect: 0, masteryCount: 0 };
            }

            // Construct the expected full answer for comparison and display
            const expectedFullAnswer = getFullConjugatedPhrase(
                currentQuestion.pronoun,
                correctConjugation,
                currentQuestion.infinitive
            );

            // Normalize answers for comparison (remove accents and convert to lowercase)
            const normalizedUserAnswer = userAnswer.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            const normalizedCorrectConjugation = correctConjugation.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");


            // Compare only the conjugation part, as the pronoun is given
            if (normalizedUserAnswer === normalizedCorrectConjugation) {
                feedbackDiv.textContent = "Richtig! 🎉";
                feedbackDiv.className = "text-center feedback-message feedback-correct";
                quizProgress[questionKey].correct++;
                quizProgress[questionKey].masteryCount++; // Increment mastery count on correct answer
            } else {
                const distance = levenshteinDistance(normalizedUserAnswer, normalizedCorrectConjugation);
                if (distance > 0 && distance <= 2 && Math.abs(normalizedUserAnswer.length - normalizedCorrectConjugation.length) <= 2) {
                    feedbackDiv.textContent = `Fast richtig! Die korrekte Antwort ist: ${expectedFullAnswer}`;
                    feedbackDiv.className = "text-center feedback-message feedback-almost";
                } else {
                    feedbackDiv.textContent = `Falsch! Die korrekte Antwort ist: ${expectedFullAnswer}`;
                    feedbackDiv.className = "text-center feedback-message feedback-wrong";
                }
                quizProgress[questionKey].incorrect++;
                quizProgress[questionKey].masteryCount = 0; // Reset mastery count on incorrect answer
            }

            // Always pronounce the expected full answer after checking
            speakFrench(expectedFullAnswer);

            saveProgress();
            updateProgressDisplay();

            checkAnswerBtn.classList.add('hidden');
            nextVerbBtn.classList.remove('hidden');
        }

        // Function to find and set the French voice for Web Speech API
        function setFrenchVoice() {
            const voices = speechSynthesis.getVoices();
            // Try to find a French voice, prioritizing common system voices like 'Thomas', 'Amelie', or 'Samantha'
            frenchVoice = voices.find(voice => voice.lang === 'fr-FR' && voice.name.includes('Thomas')) ||
                        voices.find(voice => voice.lang === 'fr-FR' && voice.name.includes('Amelie')) ||
                        voices.find(voice => voice.lang === 'fr-FR' && voice.name.includes('Samantha')) ||
                        voices.find(voice => voice.lang === 'fr-FR'); // Fallback to any fr-FR voice
            if (!frenchVoice) {
                console.warn("No 'fr-FR' voice found. Speech synthesis might use default or fail.");
            } else {
                console.log("French voice loaded:", frenchVoice.name);
            }
        }

        // Event listener for voices changed (crucial for iOS and some browsers)
        if ('speechSynthesis' in window) {
            speechSynthesis.onvoiceschanged = setFrenchVoice;
            // Call immediately if voices are already loaded (e.g., on desktop)
            setFrenchVoice();
        }

        /**
         * Pronounces the given French text using Web Speech API.
         * @param {string} text - The text to pronounce.
         */
        function speakFrench(text) {
            if ('speechSynthesis' in window) {
                // Stop any ongoing speech to prevent overlap
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'fr-FR';
                if (frenchVoice) { // Use the specific French voice if found
                    utterance.voice = frenchVoice;
                }
                speechSynthesis.speak(utterance);
            } else {
                const messageBox = document.createElement('div');
                messageBox.className = 'fixed inset-0 bg-gray-600 bg-opacity50 flex items-center justify-center z-50';
                messageBox.innerHTML = `
                    <div class="modal-box">
                        <p class="text-lg font-semibold mb-4">Browser-Funktion nicht unterstützt</p>
                        <p>Dein Browser unterstützt die Web Speech API für die Aussprache nicht.</p>
                        <button class="btn btn-primary mt-4" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);
            }
        }

        /**
         * Moves to the next verb in the quiz.
         */
        function nextVerb() {
            currentVerbIndex++;
            displayQuestion(); // Just call displayQuestion to get the next dynamic question
        }

        /**
         * Updates the progress bar on the quiz screen.
         */
        function updateProgressBar() {
            const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
            const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);
            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];

            let totalConjugationsInCurrentGroup = 0;
            let masteredConjugationsInCurrentGroup = 0;

            currentGroupInfinitives.forEach(infinitive => {
                const verb = verbsData.find(v => v.infinitive === infinitive);
                if (verb) {
                    selectedTenses.forEach(tenseKey => {
                        selectedPronouns.forEach(pronounKey => {
                            if (verb.conjugations[tenseKey] && verb.conjugations[tenseKey][pronounKey]) {
                                totalConjugationsInCurrentGroup++;
                                const questionKey = `${infinitive}-${tenseKey}-${pronounKey}`;
                                if (quizProgress[questionKey] && quizProgress[questionKey].masteryCount >= REQUIRED_MASTERY_COUNT) {
                                    masteredConjugationsInCurrentGroup++;
                                }
                            }
                        });
                    });
                }
            });

            let progressPercentage = 0;
            if (totalConjugationsInCurrentGroup > 0) {
                progressPercentage = (masteredConjugationsInCurrentGroup / totalConjugationsInCurrentGroup) * 100;
            }

            progressBar.style.width = `${progressPercentage}%`;
            progressBarText.textContent = `${Math.round(progressPercentage)}%`;
        }

        /**
         * Checks if the current learning group is mastered and advances to the next group if so.
         */
        function checkAndAdvanceGroup() {
            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            let allCurrentGroupVerbsMastered = true;

            if (currentGroupInfinitives.length === 0) {
                allCurrentGroupVerbsMastered = false; // Cannot master an empty group
            } else {
                const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
                const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);

                for (const infinitive of currentGroupInfinitives) {
                    let verbMasteredInGroup = true;
                    // Check all relevant conjugations for this verb
                    selectedTenses.forEach(tenseKey => {
                        selectedPronouns.forEach(pronounKey => {
                            const questionKey = `${infinitive}-${tenseKey}-${pronounKey}`;
                            // A conjugation is considered "mastered" if its masteryCount meets the requirement
                            if (!quizProgress[questionKey] || quizProgress[questionKey].masteryCount < REQUIRED_MASTERY_COUNT) {
                                verbMasteredInGroup = false;
                            }
                        });
                    });
                    if (!verbMasteredInGroup) {
                        allCurrentGroupVerbsMastered = false;
                        break;
                    }
                }
            }

            if (allCurrentGroupVerbsMastered && learningState.currentLearningGroupIndex < learningState.verbGroups.length - 1) {
                learningState.currentLearningGroupIndex++;
                saveLearningState();
                const messageBox = document.createElement('div');
                messageBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
                messageBox.innerHTML = `
                    <div class="modal-box">
                        <p class="text-lg font-semibold mb-4">Gruppe abgeschlossen! 🎉</p>
                        <p>Du hast die aktuelle Verbengruppe gemeistert und bist zur nächsten Gruppe fortgeschritten.</p>
                        <button class="btn btn-primary mt-4" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);
            } else if (allCurrentGroupVerbsMastered && learningState.currentLearningGroupIndex === learningState.verbGroups.length - 1) {
                const messageBox = document.createElement('div');
                messageBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
                messageBox.innerHTML = `
                    <div class="modal-box">
                        <p class="text-lg font-semibold mb-4">Alle Verben gemeistert! 🎉</p>
                        <p>Du hast alle Verben in allen Gruppen gemeistert. Herzlichen Glückwunsch!</p>
                        <button class="btn btn-primary mt-4" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);
            }
        }


        // --- Progress Tracking ---

        /**
         * Loads quiz progress and study time from localStorage.
         */
        function loadProgress() {
            const storedProgress = localStorage.getItem('frenchVerbQuizProgress');
            if (storedProgress) {
                quizProgress = JSON.parse(storedProgress);
                // Ensure masteryCount is initialized for existing progress entries
                for (const key in quizProgress) {
                    if (quizProgress[key].masteryCount === undefined) {
                        quizProgress[key].masteryCount = 0;
                    }
                }
            } else {
                quizProgress = {};
            }

            const storedStudyTime = localStorage.getItem('frenchVerbQuizStudyTime');
            if (storedStudyTime) {
                studyTimeSeconds = parseInt(storedStudyTime, 10);
            } else {
                studyTimeSeconds = 0;
            }
        }

        /**
         * Saves quiz progress and study time to localStorage.
         */
        function saveProgress() {
            localStorage.setItem('frenchVerbQuizProgress', JSON.stringify(quizProgress));
            localStorage.setItem('frenchVerbQuizStudyTime', studyTimeSeconds.toString());
        }

        /**
         * Updates the progress display on the setup screen.
         */
        function updateProgressDisplay() {
            let totalAnswered = 0;
            let correctAnswers = 0;
            let verbsToReview = 0; // Now represents verbs in the current group not yet mastered

            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];

            // Count verbs in the current group that are not yet mastered
            currentGroupInfinitives.forEach(infinitive => {
                let verbMasteredInGroup = true;
                const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
                const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);

                selectedTenses.forEach(tenseKey => {
                        selectedPronouns.forEach(pronounKey => {
                            const questionKey = `${infinitive}-${tenseKey}-${pronounKey}`;
                            if (!quizProgress[questionKey] || quizProgress[questionKey].masteryCount < REQUIRED_MASTERY_COUNT) {
                                verbMasteredInGroup = false;
                            }
                        });
                    });
                if (!verbMasteredInGroup) {
                    verbsToReview++;
                }
            });


            for (const key in quizProgress) {
                totalAnswered += quizProgress[key].correct + quizProgress[key].incorrect;
                correctAnswers += quizProgress[key].correct;
            }

            totalAnsweredSpan.textContent = totalAnswered;
            correctAnswersSpan.textContent = correctAnswers;
            verbsToReviewSpan.textContent = verbsToReview; // Display count of verbs in current group not mastered
            updateStudyTimeDisplay(); // Update study time display
        }

        /**
         * Formats seconds into a human-readable string (e.g., "5m 30s").
         * @param {number} totalSeconds - The total number of seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds}s`;
        }

        /**
         * Updates the study time display.
         */
        function updateStudyTimeDisplay() {
            studyTimeSpan.textContent = formatTime(studyTimeSeconds);
        }

        /**
         * Starts the study timer.
         */
        function startTimer() {
            // Clear any existing timer to prevent multiple timers running
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            timerInterval = setInterval(() => {
                studyTimeSeconds++;
                updateStudyTimeDisplay();
                saveProgress(); // Save time frequently
            }, 1000); // Update every second
        }

        /**
         * Stops the study timer.
         */
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        /**
         * Clears all stored progress from localStorage.
         */
        function clearProgress() {
            const messageBox = document.createElement('div');
            messageBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
            messageBox.innerHTML = `
                <div class="modal-box">
                    <p class="text-lg font-semibold mb-4">Fortschritt löschen?</p>
                    <p>Bist du sicher, dass du deinen gesamten Quiz-Fortschritt löschen möchtest? Dies kann nicht rückgängig gemacht werden.</p>
                    <div class="flex justify-center gap-4 mt-4">
                        <button id="confirmClear" class="btn btn-danger">Ja, löschen</button>
                        <button id="cancelClear" class="btn btn-secondary">Abbrechen</button>
                    </div>
                </div>
            `;
            document.body.appendChild(messageBox);

            document.getElementById('confirmClear').onclick = () => {
                localStorage.removeItem('frenchVerbQuizProgress');
                localStorage.removeItem('frenchVerbQuizStudyTime');
                localStorage.removeItem('verbGroups'); // Clear verb groups
                localStorage.removeItem('currentLearningGroupIndex'); // Clear current group index
                localStorage.removeItem('learningSeed'); // Clear the seed

                quizProgress = {};
                studyTimeSeconds = 0;
                learningState = { verbGroups: [], currentLearningGroupIndex: 0, seed: null }; // Reset learning state
                initializeVerbGroups(); // Re-initialize groups with a new random seed
                updateProgressDisplay();
                messageBox.remove();
                const successBox = document.createElement('div');
                successBox.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
                successBox.innerHTML = `
                    <div class="modal-box">
                        <p class="text-lg font-semibold mb-4">Fortschritt gelöscht!</p>
                        <button class="btn btn-primary mt-4" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                `;
                document.body.appendChild(successBox);
            };
            document.getElementById('cancelClear').onclick = () => {
                messageBox.remove();
            };
        }

        // --- Modal Functions ---
        function showVerbGroupInfoModal() {
            verbListUl.innerHTML = ''; // Clear previous list

            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            if (currentGroupInfinitives.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Keine Verben in dieser Gruppe.';
                verbListUl.appendChild(li);
            } else {
                currentGroupInfinitives.forEach(infinitive => {
                    const verbData = verbsData.find(v => v.infinitive === infinitive);
                    const li = document.createElement('li');
                    if (verbData) {
                        li.textContent = `${verbData.infinitive} (${verbData.translation})`;
                    } else {
                        li.textContent = infinitive; // Fallback if verb data not found
                    }

                    // Add mastery status
                    const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
                    const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);

                    let allConjugationsMasteredForThisVerb = true;
                    let masteryInfo = [];

                    selectedTenses.forEach(tenseKey => {
                        selectedPronouns.forEach(pronounKey => {
                            const questionKey = `${infinitive}-${tenseKey}-${pronounKey}`;
                            const progress = quizProgress[questionKey];
                            const currentMastery = progress ? progress.masteryCount : 0;
                            masteryInfo.push(`${formatPronoun(pronounKey)} ${formatTenseName(tenseKey)}: ${currentMastery}/${REQUIRED_MASTERY_COUNT}`);
                            if (currentMastery < REQUIRED_MASTERY_COUNT) {
                                allConjugationsMasteredForThisVerb = false;
                            }
                        });
                    });

                    const masterySpan = document.createElement('span');
                    masterySpan.className = 'text-sm ml-2';
                    if (allConjugationsMasteredForThisVerb && selectedTenses.length > 0 && selectedPronouns.length > 0) {
                        masterySpan.textContent = ' (Gemeistert ✅)';
                        masterySpan.classList.add('text-green-600');
                    } else if (selectedTenses.length === 0 || selectedPronouns.length === 0) {
                        masterySpan.textContent = ' (Wähle Zeitformen/Pronomen für Status)';
                        masterySpan.classList.add('text-gray-500');
                    } else {
                        masterySpan.textContent = ` (${masteryInfo.join(', ')})`;
                        masterySpan.classList.add('text-red-500');
                    }
                    li.appendChild(masterySpan);
                    verbListUl.appendChild(li);
                });
            }

            verbGroupInfoModal.classList.remove('hidden');
        }

        function hideVerbGroupInfoModal() {
            verbGroupInfoModal.classList.add('hidden');
        }

        // --- Event Listeners ---

        startQuizBtn.addEventListener('click', startQuiz);
        checkAnswerBtn.addEventListener('click', checkAnswer);
        nextVerbBtn.addEventListener('click', nextVerb);

        answerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (checkAnswerBtn.classList.contains('hidden')) {
                    nextVerb();
                } else {
                    checkAnswer();
                }
            }
        });
        clearProgressBtn.addEventListener('click', clearProgress);
        changeSeedBtn.addEventListener('click', () => {
            const newSeed = seedInput.value.trim();
            initializeVerbGroups(newSeed); // Re-initialize with the new seed
        });

        // Modal event listeners
        infoIcon.addEventListener('click', showVerbGroupInfoModal);
        closeVerbGroupInfoModalBtn.addEventListener('click', hideVerbGroupInfoModal);
        verbGroupInfoModal.addEventListener('click', (e) => {
            if (e.target === verbGroupInfoModal) { // Close when clicking outside modal content
                hideVerbGroupInfoModal();
            }
        });


        // Initial fetch and render when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            await fetchVerbsData(); // This calls initializeVerbGroups internally
            // After fetchVerbsData and initializeVerbGroups, learningState.seed should be populated
            if (currentSeedDisplay && learningState.seed !== null) {
                currentSeedDisplay.textContent = learningState.seed;
            } else if (currentSeedDisplay) {
                currentSeedDisplay.textContent = "Nicht festgelegt (wird beim Start generiert)";
            }
        });
    </script>
</body>
</html>
