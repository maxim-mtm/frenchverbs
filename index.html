<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Französisch-Verben-Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Lighter blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure it takes full viewport height */
            padding: 1.5rem; /* Increased overall padding */
        }
        .container {
            max-width: 768px; /* Reduced max-width for a less wide horizontal feel */
            width: 100%; /* Ensure it takes full width on smaller screens */
        }
        .card {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.05); /* Stronger shadow */
            padding: 2.5rem; /* Increased padding */
        }
        /* Style for multi-select dropdowns */
        .filter-select[multiple] {
            height: auto;
            min-height: 120px;
            padding: 0.75rem;
            border: 1px solid #cbd5e0; /* Light gray border */
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
            transition: all 0.2s ease-in-out;
        }
        .filter-select[multiple]:focus {
            outline: none;
            border-color: #6366f1; /* Indigo-500 on focus */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); /* Focus ring */
        }
        .filter-select[multiple]::-ms-expand {
            display: none;
        }
        .filter-select[multiple] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none;
            padding-right: 0.75rem;
        }

        /* Button Styling */
        .btn {
            font-weight: 700; /* Bold font */
            padding: 0.75rem 1.5rem; /* Increased padding */
            border-radius: 0.75rem; /* More rounded */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Indigo-700 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-success {
            background-color: #22c55e; /* Green-500 */
            color: white;
        }
        .btn-success:hover {
            background-color: #16a34a; /* Green-600 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red-500 */
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Red-600 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Gray-200 */
            color: #374151; /* Gray-700 */
        }
        .btn-secondary:hover {
            background-color: #d1d5db; /* Gray-300 */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5; /* Indigo for spinner */
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .irregularity-tag {
            display: inline-block;
            padding: 0.25rem 0.6rem; /* Slightly more padding */
            margin: 0.25rem;
            border-radius: 0.75rem; /* More rounded pill shape */
            font-size: 0.7rem; /* Slightly smaller font */
            font-weight: 600;
            color: #ffffff;
            background-color: #f97316; /* Orange-500 for irregularities */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
        }
        /* Removed .pronunciation-button styles as the button is removed */

        .feedback-message {
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            font-size: 1.25rem; /* Larger font */
            font-weight: 700; /* Bolder */
        }
        .feedback-correct {
            background-color: #dcfce7; /* Green-100 */
            color: #16a34a; /* Green-600 */
        }
        .feedback-almost {
            background-color: #ffedd5; /* Orange-100 */
            color: #ea580c; /* Orange-700 */
        }
        .feedback-wrong {
            background-color: #fee2e2; /* Red-100 */
            color: #dc2626; /* Red-600 */
        }
        .feedback-info {
            background-color: #e0f2fe; /* Blue-100 */
            color: #2563eb; /* Blue-600 */
        }
        .modal-box {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            background-color: #60a5fa; /* Blue-400 */
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .info-icon:hover {
            background-color: #3b82f6; /* Blue-500 */
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280; /* Gray-500 */
        }
        .modal-close-btn:hover {
            color: #1f2937; /* Gray-800 */
        }
    </style>
</head>
<body class="p-4">
    <div class="container mx-auto mt-8 card">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-6">Französisch-Verben-Quiz</h1>
        <p class="text-center text-gray-600 mb-8">
            Teste dein Wissen über französische Verbkonjugationen!
        </p>

        <div id="quizSetupScreen" class="">
            <h2 class="text-2xl font-bold text-gray-700 mb-4">Quiz-Einstellungen</h2>
            <div class="flex flex-col md:flex-row justify-center items-start gap-6 mb-8">
                <div class="w-full md:w-1/2">
                    <label for="tenseFilter" class="block text-gray-700 text-sm font-bold mb-2">Wähle Zeitform(en):</label>
                    <select id="tenseFilter" multiple size="4" class="filter-select block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 ease-in-out">
                        <option value="present">Présent</option>
                        <option value="imparfait">Imparfait</option>
                        <option value="passe_compose">Passé Composé</option>
                    </select>
                </div>

                <div class="w-full md:w-1/2">
                    <label for="pronounFilter" class="block text-gray-700 text-sm font-bold mb-2">Wähle Pronomen:</label>
                    <select id="pronounFilter" multiple size="6" class="filter-select block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 ease-in-out">
                        <option value="je">Je</option>
                        <option value="tu">Tu</option>
                        <option value="il">Il/Elle/On</option>
                        <option value="nous">Nous</option>
                        <option value="vous">Vous</option>
                        <option value="ils">Ils/Elles</option>
                    </select>
                </div>
            </div>

            <!-- Learning mode toggle -->
            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">Lernmodus:</label>
                <div class="flex items-center space-x-4">
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio text-blue-600" name="learningMode" value="groups" checked>
                        <span class="ml-2">Verben in Gruppen lernen</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio text-blue-600" name="learningMode" value="all">
                        <span class="ml-2">Alle Verben auf einmal lernen</span>
                    </label>
                </div>
            </div>

            <div id="seedGroupControls" class="mb-6">
                <label for="seedInput" class="block text-gray-700 text-sm font-bold mb-2">
                    Seed für Verbengruppen (optional):
                    <span id="infoIcon" class="info-icon" title="Zeigt die Verben in der aktuellen Lerngruppe an.">i</span>
                </label>
                <div class="flex items-center">
                    <input type="text" id="seedInput" class="flex-grow p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-lg transition duration-200 ease-in-out" placeholder="Gib hier einen Seed ein oder lasse es leer">
                    <button id="changeSeedBtn" class="btn btn-secondary ml-2 px-4 py-3 text-sm">Seed ändern</button>
                </div>
                <p class="text-sm text-gray-500 mt-2">
                    Aktueller Seed: <span id="currentSeedDisplay" class="font-semibold text-gray-700"></span>
                    <br>
                    <span class="text-xs text-gray-400">Gib einen neuen Seed oben ein und klicke auf "Seed ändern", um die Verbengruppen neu zu generieren.</span>
                </p>
            </div>

            <div id="setupFeedback" class="text-center text-xl font-bold mb-6"></div>

            <button id="startQuizBtn" class="btn btn-success w-full mb-6">Quiz starten</button>

            <div id="progressDisplay" class="bg-gray-100 p-6 rounded-lg text-gray-700 shadow-inner">
                <h3 class="text-xl font-semibold mb-3">Dein Fortschritt:</h3>
                <p class="mb-1">Insgesamt beantwortete Fragen: <span id="totalAnswered" class="font-bold text-gray-900">0</span></p>
                <p class="mb-1">Richtige Antworten: <span id="correctAnswers" class="font-bold text-green-600">0</span></p>
                <p class="mb-1">Zu wiederholende Verben: <span id="verbsToReview" class="font-bold text-red-500">0</span></p>
                <p>Zeit Genutz zum Üben: <span id="studyTime" class="font-bold text-gray-900">0m 0s</span></p>
                <button id="clearProgressBtn" class="btn btn-danger mt-6">Fortschritt löschen</button>
            </div>
        </div>

        <div id="quizScreen" class="hidden">
            <h2 class="text-2xl font-bold text-gray-700 mb-4">Quiz läuft</h2>
            <div class="bg-blue-50 p-8 rounded-lg text-center mb-6 shadow-md">
                <p class="text-xl text-gray-600 mb-2">Infinitiv:</p>
                <p id="quizInfinitive" class="text-4xl font-extrabold text-blue-800 mb-6"></p>
                <p class="text-lg text-gray-600 mb-2">Zeitform:</p>
                <p id="quizTense" class="text-2xl font-semibold text-blue-700 mb-4"></p>
            </div>

            <div class="w-full bg-gray-200 rounded-full h-4 mb-6">
                <div id="progressBar" class="bg-blue-600 h-4 rounded-full text-xs flex items-center justify-center text-white" style="width: 0%;">
                    <span id="progressBarText">0%</span>
                </div>
            </div>

            <div class="flex flex-col items-center justify-center gap-4 mb-6">
                <div class="flex items-center w-full max-w-sm">
                    <span id="quizPronounPrefix" class="text-2xl font-semibold text-blue-700 mr-2 min-w-[5rem] text-right"></span>
                    <input type="text" id="answerInput" class="flex-grow p-3 border-2 border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-lg transition duration-200 ease-in-out" placeholder="Gib deine Konjugation hier ein">
                </div>
            </div>

            <div id="feedback" class="text-center feedback-message"></div>

            <div class="flex justify-center gap-4 mt-6">
                <button id="checkAnswerBtn" class="btn btn-primary">Antwort prüfen</button>
                <button id="nextVerbBtn" class="btn btn-secondary hidden">Nächstes Verb</button>
            </div>
        </div>
    </div>

    <div id="verbGroupInfoModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="closeVerbGroupInfoModal">&times;</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Verben in der aktuellen Gruppe</h3>
            <ul id="verbList" class="list-disc list-inside text-left text-gray-700">
                </ul>
            <p class="text-sm text-gray-600 mt-4">
                Ein Verb gilt als gemeistert, wenn es <span class="font-bold">5</span> Mal richtig beantwortet wurde.
            </p>
        </div>
    </div>

    <script>
        let verbsData = []; // This will store the data fetched from verbs.json
        let quizVerbs = []; // This will now store all questions for the current quiz session
        let currentVerbIndex = 0; // Tracks the current question within the quizVerbs array
        let currentQuizSessionQuestionsAnswered = 0; // Tracks questions answered in the current session
        let currentQuestion = {}; // Stores the current verb, tense, and pronoun for the question
        let quizProgress = {}; // Stores user progress for each conjugation (correct/incorrect counts)
        let studyTimeSeconds = 0; // Total accumulated study time in seconds
        let timerInterval = null; // Holds the setInterval ID for the timer

        // New state for learning algorithm
        let learningState = {
            verbGroups: [], // Array of arrays of verb infinitives (randomly assigned)
            currentLearningGroupIndex: 0, // Index of the current group being learned
            seed: null // The seed used to generate verb groups
        };

        const GROUP_SIZE = 15; // Number of verbs per learning group
        const SESSION_TOTAL_QUESTIONS = 20; // Total questions in one quiz session
        const REQUIRED_MASTERY_COUNT = 5; // Number of correct answers needed to consider a conjugation "learned" for group advancement
        const NEXT_GROUP_MIX_START_PERCENTAGE = 0.5; // Start mixing next group verbs when current group is 50% done
        const NEXT_GROUP_MIX_END_PERCENTAGE = 0.9; // Max mixing of next group verbs when current group is 90% done
        const REVIEW_PREVIOUS_GROUP_CHANCE = 0.2; // Constant chance to pull from previous groups (20%)

        // Global seeded random instance
        let seededRand = null;

        class SeededRandom {
            constructor(seed) {
                // Ensure seed is a number and positive for the LCG
                this.seed = typeof seed === 'string' ? seed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) : seed;
                this.seed = this.seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }

            next() {
                // Linear Congruential Generator parameters (a, c, m)
                // m = 2^31 - 1 (a common prime modulus)
                // a = 1103515245, c = 12345
                this.seed = (this.seed * 1103515245 + 12345) % 2147483647;
                return this.seed / 2147483647; // Return a float between 0 and 1
            }

            // Fisher-Yates shuffle using this PRNG
            shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(this.next() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
        }

        // Get references to DOM elements
        const quizSetupScreen = document.getElementById('quizSetupScreen');
        const quizScreen = document.getElementById('quizScreen');
        const tenseFilter = document.getElementById('tenseFilter');
        const pronounFilter = document.getElementById('pronounFilter');
        const startQuizBtn = document.getElementById('startQuizBtn');
        const setupFeedbackDiv = document.getElementById('setupFeedback'); // Feedback div for setup screen

        const quizInfinitive = document.getElementById('quizInfinitive');
        const quizTense = document.getElementById('quizTense');
        const quizPronounPrefix = document.getElementById('quizPronounPrefix'); // New element for pronoun prefix
        const answerInput = document.getElementById('answerInput');
        const feedbackDiv = document.getElementById('feedback'); // Feedback div for quiz screen
        const checkAnswerBtn = document.getElementById('checkAnswerBtn');
        const nextVerbBtn = document.getElementById('nextVerbBtn');

        const progressBar = document.getElementById('progressBar'); // Progress bar element
        const progressBarText = document.getElementById('progressBarText'); // Text inside progress bar

        const totalAnsweredSpan = document.getElementById('totalAnswered');
        const correctAnswersSpan = document.getElementById('correctAnswers');
        const verbsToReviewSpan = document.getElementById('verbsToReview');
        const studyTimeSpan = document.getElementById('studyTime'); // New study time span
        const clearProgressBtn = document.getElementById('clearProgressBtn');

        const seedInput = document.getElementById('seedInput'); // New seed input field
        const currentSeedDisplay = document.getElementById('currentSeedDisplay'); // New element to display current seed
        const changeSeedBtn = document.getElementById('changeSeedBtn'); // New button to change seed

        // New elements for the modal
        const infoIcon = document.getElementById('infoIcon');
        const verbGroupInfoModal = document.getElementById('verbGroupInfoModal');
        const closeVerbGroupInfoModalBtn = document.getElementById('closeVerbGroupInfoModal');
        const verbListUl = document.getElementById('verbList');

        // --- Utility Functions ---

        /**
         * Formats the tense key for display.
         * @param {string} key - The tense key (e.g., 'passe_compose').
         * @returns {string} The formatted tense name (e.g., 'Passé Composé').
         */
        function formatTenseName(key) {
            switch (key) {
                case 'present': return 'Présent';
                case 'imparfait': return 'Imparfait';
                case 'passe_compose': return 'Passé Composé';
                default: return key;
            }
        }

        /**
         * Formats the pronoun key for display.
         * @param {string} key - The pronoun key (e.g., 'il').
         * @returns {string} The formatted pronoun (e.g., 'Il/Elle/On').
         */
        function formatPronoun(key) {
            switch (key) {
                case 'je': return 'Je';
                case 'tu': return 'Tu';
                case 'il': return 'Il/Elle/On';
                case 'nous': return 'Nous';
                case 'vous': return 'Vous';
                case 'ils': return 'Ils/Elles';
                default: return key;
            }
        }

        /**
         * Returns the single pronoun for construction (e.g., 'il' for 'il/elle/on').
         * Used for constructing the full conjugated phrase.
         * @param {string} key - The pronoun key (e.g., 'il').
         * @returns {string} The single pronoun string.
         */
        function getSinglePronounForConstruction(key) {
            switch (key) {
                case 'je': return 'je';
                case 'tu': return 'tu';
                case 'il': return 'il';
                case 'nous': return 'nous';
                case 'vous': return 'vous';
                case 'ils': return 'ils';
                default: return key;
            }
        }

        /**
         * Constructs the full conjugated phrase (pronoun + verb) for display/pronunciation.
         * Handles contractions like j' and reflexive verbs.
         * @param {string} pronounKey - The internal pronoun key (e.g., 'je', 'il').
         * @param {string} conjugation - The conjugated verb form (e.g., 'ai', 'suis allé(e)').
         * @param {string} infinitive - The infinitive of the current verb (to check for impersonal/reflexive).
         * @returns {string} The full conjugated phrase (e.g., 'j'ai', 'il mange', 'nous nous levons').
         */
        function getFullConjugatedPhrase(pronounKey, conjugation, infinitive) {
            // Special handling for impersonal verbs (falloir, pleuvoir) which don't use a pronoun in the phrase
            if (infinitive === "falloir" || infinitive === "pleuvoir") {
                return conjugation;
            }

            // Check if the verb is reflexive based on its infinitive (starts with "s'")
            const isReflexiveVerb = infinitive.startsWith("s'");

            // If it's a reflexive verb, the conjugation already contains the reflexive pronoun.
            // Just return the conjugation as is.
            if (isReflexiveVerb) {
                return conjugation;
            }

            // Handle 'je' contraction for verbs starting with a vowel or silent 'h'
            const firstLetterOfConjugation = conjugation.charAt(0).toLowerCase();
            const isVowelOrSilentH = ['a', 'e', 'i', 'o', 'u', 'h'].includes(firstLetterOfConjugation);

            if (pronounKey === 'je' && isVowelOrSilentH) {
                return `j'${conjugation}`;
            }

            // For all other cases, prepend the standard pronoun and a space
            return `${getSinglePronounForConstruction(pronounKey)} ${conjugation}`;
        }

        /**
         * Calculates the Levenshtein distance between two strings.
         * Used for "almost" correct checking.
         * @param {string} s1 - First string.
         * @param {string} s2 - Second string.
         * @returns {number} The Levenshtein distance.
         */
        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(newValue, lastValue, costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) {
                    costs[s2.length] = lastValue;
                }
            }
            return costs[s2.length];
        }

        // --- Learning Algorithm & Quiz Logic ---

        /**
         * Initializes verb groups. Can force re-initialization with a specific seed.
         * @param {string|number} [forceSeed=null] - Optional seed to force re-initialization.
         */
        function initializeVerbGroups(forceSeed = null) {
            let storedVerbGroups = localStorage.getItem('verbGroups');
            let storedCurrentGroupIndex = localStorage.getItem('currentLearningGroupIndex');
            let storedSeed = localStorage.getItem('learningSeed'); // New: load stored seed

            let needsReinitialization = true;
            let effectiveSeed = null;

            if (forceSeed !== null) {
                // User explicitly provided a seed, force re-initialization
                effectiveSeed = typeof forceSeed === 'string' ? forceSeed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) : forceSeed;
                console.log("Forcing re-initialization with seed:", effectiveSeed);
            } else if (storedVerbGroups && storedCurrentGroupIndex !== null && storedSeed !== null) {
                try {
                    const parsedGroups = JSON.parse(storedVerbGroups);
                    const totalVerbsInStoredGroups = parsedGroups.flat().length;
                    // Check if all verbs from verbsData are present in the parsed groups
                    const allVerbsPresent = verbsData.every(verb => parsedGroups.flat().includes(verb.infinitive));

                    // Add check for GROUP_SIZE consistency
                    const firstGroupSize = parsedGroups.length > 0 ? parsedGroups[0].length : 0;
                    const groupSizeConsistent = parsedGroups.every(group => group.length <= GROUP_SIZE); // Last group might be smaller

                    if (totalVerbsInStoredGroups === verbsData.length && allVerbsPresent && groupSizeConsistent) {
                        learningState.verbGroups = parsedGroups;
                        learningState.currentLearningGroupIndex = parseInt(storedCurrentGroupIndex, 10);
                        learningState.seed = storedSeed; // Load the seed into learningState
                        effectiveSeed = storedSeed;
                        needsReinitialization = false;
                        console.log("Loaded existing verb groups with seed:", effectiveSeed);
                    } else {
                        console.warn("Stored verb groups are inconsistent (e.g., size changed or verbs missing), re-initializing.");
                    }
                } catch (e) {
                    console.error("Error parsing stored verb groups or seed:", e);
                }
            }

            if (needsReinitialization) {
                if (effectiveSeed === null) {
                    // No forced seed, no valid stored seed, generate a new random one
                    effectiveSeed = Date.now(); // Use timestamp for a truly random-like seed
                    console.log("Generating new random seed:", effectiveSeed);
                }

                seededRand = new SeededRandom(effectiveSeed);
                learningState.seed = effectiveSeed; // Store the seed in learningState

                let allInfinitives = verbsData.map(v => v.infinitive);
                seededRand.shuffle(allInfinitives); // Use seeded shuffle

                let groups = [];
                for (let i = 0; i < allInfinitives.length; i += GROUP_SIZE) {
                    groups.push(allInfinitives.slice(i, i + GROUP_SIZE));
                }
                learningState.verbGroups = groups;
                learningState.currentLearningGroupIndex = 0; // Start with the first group
                saveLearningState(); // Save initial state
                console.log("Verb groups initialized/re-initialized.");
            } else {
                // If not re-initializing, ensure seededRand is set for subsequent shuffles (though not strictly needed for session generation)
                seededRand = new SeededRandom(effectiveSeed);
            }

            // Update the seed display in the UI
            if (currentSeedDisplay) {
                currentSeedDisplay.textContent = learningState.seed;
            }
            updateProgressDisplay(); // Update progress display after seed change
        }

        /**
         * Saves the current learning state (verb groups and current group index) to localStorage.
         */
        function saveLearningState() {
            localStorage.setItem('verbGroups', JSON.stringify(learningState.verbGroups));
            localStorage.setItem('currentLearningGroupIndex', learningState.currentLearningGroupIndex.toString());
            localStorage.setItem('learningSeed', learningState.seed.toString()); // Save the seed
        }

        /**
         * Fetches verb data from the specified URL.
         */
        async function fetchVerbsData() {
            try {
                // Use the provided URL for verbs.json
                const response = await fetch('https://maxim-mtm.github.io/frenchverbs/verbs.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                verbsData = await response.json();
                console.log("Verbs data loaded:", verbsData.length, "verbs.");
                initializeVerbGroups(); // Initialize groups after verbsData is loaded
                loadProgress(); // Load quiz progress
                updateProgressDisplay();
            } catch (error) {
                console.error('Error fetching verbs data:', error);
                if (quizSetupScreen) {
                    setupFeedbackDiv.textContent = 'Fehler beim Laden der Verben. Bitte stelle sicher, dass verbs.json unter der korrekten URL verfügbar ist.';
                    setupFeedbackDiv.classList.add('feedback-wrong');
                }
            }
        }

        /**
         * Generates the questions for the current quiz session based on the learning algorithm.
         */
        function generateQuizSessionQuestions() {
            const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
            const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);
            const learningMode = document.querySelector('input[name="learningMode"]:checked').value;

            if (selectedTenses.length === 0 || selectedPronouns.length === 0) {
                setupFeedbackDiv.textContent = "Bitte wähle mindestens eine Zeitform und ein Pronomen, um das Quiz zu starten.";
                setupFeedbackDiv.classList.add('feedback-info');
                return [];
            }

            // If learning all verbs at once, just use all infinitives
            if (learningMode === 'all') {
                const allInfinitives = verbsData.map(v => v.infinitive);
                let questions = [];
                
                // Generate questions from all verbs
                for (const infinitive of allInfinitives) {
                    const verb = verbsData.find(v => v.infinitive === infinitive);
                    if (!verb) continue;
                    
                    for (const tense of selectedTenses) {
                        if (!verb.conjugations[tense]) continue;
                        
                        for (const pronoun of selectedPronouns) {
                            if (!verb.conjugations[tense][pronoun]) continue;
                            
                            questions.push({
                                infinitive,
                                tense,
                                pronoun,
                                conjugation: verb.conjugations[tense][pronoun]
                            });
                        }
                    }
                }
                
                // Shuffle questions
                seededRand.shuffle(questions);
                return questions.slice(0, SESSION_TOTAL_QUESTIONS);
            }
            
            // Otherwise, use the group-based learning algorithm
            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            const nextGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex + 1] || [];
            let previousGroupsInfinitives = [];
            for (let i = 0; i < learningState.currentLearningGroupIndex; i++) {
                previousGroupsInfinitives = previousGroupsInfinitives.concat(learningState.verbGroups[i]);
            }

            let currentGroupQuestions = [];
            let nextGroupQuestions = [];
            let previousGroupQuestions = [];

            // Helper to generate questions from a list of infinitives
            const generateQuestionsForInfinitives = (infinitives, poolType) => {
                let questions = [];
                for (const infinitive of infinitives) {
                    const verb = verbsData.find(v => v.infinitive === infinitive);
                    if (!verb) continue;
                    
                    for (const tense of selectedTenses) {
                        if (!verb.conjugations[tense]) continue;
                        
                        for (const pronoun of selectedPronouns) {
                            if (!verb.conjugations[tense][pronoun]) continue;
                            
                            // Get the progress for this specific conjugation
                            const progressKey = `${infinitive}-${tense}-${pronoun}`;
                            const progress = quizProgress[progressKey] || { correct: 0, incorrect: 0 };
                            
                            questions.push({
                                infinitive,
                                tense,
                                pronoun,
                                conjugation: verb.conjugations[tense][pronoun],
                                progress,
                                poolType
                            });
                        }
                    }
                }
                return questions;
            };

            // Generate questions for each group
            currentGroupQuestions = generateQuestionsForInfinitives(currentGroupInfinitives, 'current');
            nextGroupQuestions = generateQuestionsForInfinitives(nextGroupInfinitives, 'next');
            previousGroupQuestions = generateQuestionsForInfinitives(previousGroupsInfinitives, 'previous');

            // Calculate current group mastery percentage
            const currentGroupMastery = calculateGroupMasteryPercentage(currentGroupQuestions);
            
            // Determine the mix of questions based on current group mastery
            let questions = [];
            
            // Always include some questions from previous groups (20% chance)
            if (previousGroupQuestions.length > 0) {
                const numPreviousQuestions = Math.max(1, Math.floor(SESSION_TOTAL_QUESTIONS * REVIEW_PREVIOUS_GROUP_CHANCE));
                const shuffledPrevious = seededRand.shuffle([...previousGroupQuestions]);
                questions.push(...shuffledPrevious.slice(0, numPreviousQuestions));
            }
            
            // Determine how many questions to take from current and next groups
            const remainingQuestions = SESSION_TOTAL_QUESTIONS - questions.length;
            
            if (currentGroupMastery < NEXT_GROUP_MIX_START_PERCENTAGE) {
                // Focus mostly on current group (90/10 split)
                const numCurrent = Math.floor(remainingQuestions * 0.9);
                const shuffledCurrent = seededRand.shuffle([...currentGroupQuestions]);
                questions.push(...shuffledCurrent.slice(0, numCurrent));
                
                // Add some from next group if available
                if (nextGroupQuestions.length > 0) {
                    const numNext = remainingQuestions - numCurrent;
                    const shuffledNext = seededRand.shuffle([...nextGroupQuestions]);
                    questions.push(...shuffledNext.slice(0, numNext));
                }
            } else if (currentGroupMastery < NEXT_GROUP_MIX_END_PERCENTAGE) {
                // Mix current and next group based on mastery progress (linear interpolation)
                const mixRatio = (currentGroupMastery - NEXT_GROUP_MIX_START_PERCENTAGE) / 
                                (NEXT_GROUP_MIX_END_PERCENTAGE - NEXT_GROUP_MIX_START_PERCENTAGE);
                const numCurrent = Math.floor(remainingQuestions * (1 - mixRatio * 0.5)); // From 90% to 50%
                const shuffledCurrent = seededRand.shuffle([...currentGroupQuestions]);
                questions.push(...shuffledCurrent.slice(0, numCurrent));
                
                // Add from next group
                if (nextGroupQuestions.length > 0) {
                    const numNext = remainingQuestions - numCurrent;
                    const shuffledNext = seededRand.shuffle([...nextGroupQuestions]);
                    questions.push(...shuffledNext.slice(0, numNext));
                }
            } else {
                // Current group is mostly mastered (90%+), focus more on next group (50/50 split)
                const numCurrent = Math.floor(remainingQuestions * 0.5);
                const shuffledCurrent = seededRand.shuffle([...currentGroupQuestions]);
                questions.push(...shuffledCurrent.slice(0, numCurrent));
                
                // Add from next group
                if (nextGroupQuestions.length > 0) {
                    const numNext = remainingQuestions - numCurrent;
                    const shuffledNext = seededRand.shuffle([...nextGroupQuestions]);
                    questions.push(...shuffledNext.slice(0, numNext));
                }
            }
            
            // If we don't have enough questions, fill up with current group questions
            if (questions.length < SESSION_TOTAL_QUESTIONS && currentGroupQuestions.length > 0) {
                const needed = SESSION_TOTAL_QUESTIONS - questions.length;
                const shuffledCurrent = seededRand.shuffle([...currentGroupQuestions]);
                questions.push(...shuffledCurrent.slice(0, needed));
            }
            
            // Shuffle the final questions array
            seededRand.shuffle(questions);
            
            return questions.slice(0, SESSION_TOTAL_QUESTIONS);
        }

        /**
         * Calculates the mastery percentage for a group of questions.
         * @param {Array} questions - Array of question objects.
         * @returns {number} Mastery percentage (0-1).
         */
        function calculateGroupMasteryPercentage(questions) {
            if (questions.length === 0) return 0;
            
            let totalMastery = 0;
            for (const question of questions) {
                const progress = question.progress || { correct: 0, incorrect: 0 };
                const totalAttempts = progress.correct + progress.incorrect;
                const mastery = totalAttempts > 0 ? progress.correct / totalAttempts : 0;
                totalMastery += mastery;
            }
            
            return totalMastery / questions.length;
        }

        /**
         * Loads quiz progress from localStorage.
         */
        function loadProgress() {
            const savedProgress = localStorage.getItem('quizProgress');
            if (savedProgress) {
                quizProgress = JSON.parse(savedProgress);
            } else {
                quizProgress = {};
            }
            
            const savedTime = localStorage.getItem('studyTimeSeconds');
            if (savedTime) {
                studyTimeSeconds = parseInt(savedTime, 10);
            }
        }

        /**
         * Saves quiz progress to localStorage.
         */
        function saveProgress() {
            localStorage.setItem('quizProgress', JSON.stringify(quizProgress));
            localStorage.setItem('studyTimeSeconds', studyTimeSeconds.toString());
        }

        /**
         * Updates the progress display with current stats.
         */
        function updateProgressDisplay() {
            let totalAnswered = 0;
            let correctAnswers = 0;
            let verbsToReview = 0;
            
            for (const key in quizProgress) {
                totalAnswered += quizProgress[key].correct + quizProgress[key].incorrect;
                correctAnswers += quizProgress[key].correct;
                
                if (quizProgress[key].correct < REQUIRED_MASTERY_COUNT) {
                    verbsToReview++;
                }
            }
            
            totalAnsweredSpan.textContent = totalAnswered;
            correctAnswersSpan.textContent = correctAnswers;
            verbsToReviewSpan.textContent = verbsToReview;
            
            // Format study time
            const hours = Math.floor(studyTimeSeconds / 3600);
            const minutes = Math.floor((studyTimeSeconds % 3600) / 60);
            const seconds = studyTimeSeconds % 60;
            
            if (hours > 0) {
                studyTimeSpan.textContent = `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                studyTimeSpan.textContent = `${minutes}m ${seconds}s`;
            } else {
                studyTimeSpan.textContent = `${seconds}s`;
            }
        }

        /**
         * Starts the quiz session.
         */
        function startQuiz() {
            quizVerbs = generateQuizSessionQuestions();
            
            if (quizVerbs.length === 0) {
                return; // No questions generated (likely due to no tenses/pronouns selected)
            }
            
            currentVerbIndex = 0;
            currentQuizSessionQuestionsAnswered = 0;
            
            // Hide setup screen and show quiz screen
            quizSetupScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');
            
            // Start the timer if not already running
            if (!timerInterval) {
                timerInterval = setInterval(() => {
                    studyTimeSeconds++;
                    saveProgress();
                    updateProgressDisplay();
                }, 1000);
            }
            
            // Display the first question
            displayCurrentQuestion();
        }

        /**
         * Displays the current question in the quiz.
         */
        function displayCurrentQuestion() {
            if (currentVerbIndex >= quizVerbs.length) {
                // End of quiz session
                endQuizSession();
                return;
            }
            
            currentQuestion = quizVerbs[currentVerbIndex];
            
            // Update UI elements
            quizInfinitive.textContent = currentQuestion.infinitive;
            quizTense.textContent = formatTenseName(currentQuestion.tense);
            quizPronounPrefix.textContent = formatPronoun(currentQuestion.pronoun);
            
            // Clear input and feedback
            answerInput.value = '';
            feedbackDiv.textContent = '';
            feedbackDiv.className = 'text-center feedback-message';
            
            // Reset button states
            checkAnswerBtn.classList.remove('hidden');
            nextVerbBtn.classList.add('hidden');
            
            // Focus the input field
            answerInput.focus();
            
            // Update progress bar
            const progressPercentage = Math.floor((currentVerbIndex / quizVerbs.length) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressBarText.textContent = `${progressPercentage}%`;
        }

        /**
         * Checks the user's answer against the correct conjugation.
         */
        function checkAnswer() {
            const userAnswer = answerInput.value.trim();
            const correctAnswer = currentQuestion.conjugation;
            
            // Create progress key if it doesn't exist
            const progressKey = `${currentQuestion.infinitive}-${currentQuestion.tense}-${currentQuestion.pronoun}`;
            if (!quizProgress[progressKey]) {
                quizProgress[progressKey] = { correct: 0, incorrect: 0 };
            }
            
            // Check if answer is correct (case insensitive)
            const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
            
            // Check for "almost" correct answers (Levenshtein distance <= 2)
            const distance = levenshteinDistance(userAnswer, correctAnswer);
            const isAlmostCorrect = !isCorrect && distance <= 2;
            
            // Update progress
            if (isCorrect) {
                quizProgress[progressKey].correct++;
                feedbackDiv.textContent = 'Richtig! 👍';
                feedbackDiv.className = 'text-center feedback-message feedback-correct';
            } else if (isAlmostCorrect) {
                quizProgress[progressKey].incorrect++;
                feedbackDiv.textContent = `Fast richtig! Die korrekte Antwort ist: ${getFullConjugatedPhrase(currentQuestion.pronoun, correctAnswer, currentQuestion.infinitive)}`;
                feedbackDiv.className = 'text-center feedback-message feedback-almost';
            } else {
                quizProgress[progressKey].incorrect++;
                feedbackDiv.textContent = `Falsch. Die korrekte Antwort ist: ${getFullConjugatedPhrase(currentQuestion.pronoun, correctAnswer, currentQuestion.infinitive)}`;
                feedbackDiv.className = 'text-center feedback-message feedback-wrong';
            }
            
            // Save progress
            saveProgress();
            updateProgressDisplay();
            
            // Update button states
            checkAnswerBtn.classList.add('hidden');
            nextVerbBtn.classList.remove('hidden');
            
            // Increment answered count
            currentQuizSessionQuestionsAnswered++;
        }

        /**
         * Moves to the next question in the quiz.
         */
        function nextQuestion() {
            currentVerbIndex++;
            displayCurrentQuestion();
        }

        /**
         * Ends the current quiz session and returns to the setup screen.
         */
        function endQuizSession() {
            // Hide quiz screen and show setup screen
            quizScreen.classList.add('hidden');
            quizSetupScreen.classList.remove('hidden');
            
            // Show feedback about the completed session
            setupFeedbackDiv.textContent = `Quiz beendet! Du hast ${currentQuizSessionQuestionsAnswered} Fragen beantwortet.`;
            setupFeedbackDiv.className = 'text-center feedback-message feedback-info';
            
            // Check if we should advance to the next group
            checkGroupAdvancement();
        }

        /**
         * Checks if the user has mastered enough of the current group to advance.
         */
        function checkGroupAdvancement() {
            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            if (currentGroupInfinitives.length === 0) return;
            
            // Calculate mastery for current group
            let masteredVerbs = 0;
            for (const infinitive of currentGroupInfinitives) {
                const verb = verbsData.find(v => v.infinitive === infinitive);
                if (!verb) continue;
                
                let verbMastered = true;
                const selectedTenses = Array.from(tenseFilter.selectedOptions).map(option => option.value);
                const selectedPronouns = Array.from(pronounFilter.selectedOptions).map(option => option.value);
                
                for (const tense of selectedTenses) {
                    if (!verb.conjugations[tense]) continue;
                    
                    for (const pronoun of selectedPronouns) {
                        if (!verb.conjugations[tense][pronoun]) continue;
                        
                        const progressKey = `${infinitive}-${tense}-${pronoun}`;
                        const progress = quizProgress[progressKey] || { correct: 0, incorrect: 0 };
                        
                        if (progress.correct < REQUIRED_MASTERY_COUNT) {
                            verbMastered = false;
                            break;
                        }
                    }
                    
                    if (!verbMastered) break;
                }
                
                if (verbMastered) {
                    masteredVerbs++;
                }
            }
            
            const masteryPercentage = masteredVerbs / currentGroupInfinitives.length;
            
            // If 80% or more of verbs in current group are mastered, advance to next group
            if (masteryPercentage >= 0.8 && learningState.currentLearningGroupIndex < learningState.verbGroups.length - 1) {
                learningState.currentLearningGroupIndex++;
                saveLearningState();
                
                // Show feedback about group advancement
                setupFeedbackDiv.textContent += ` Glückwunsch! Du hast Gruppe ${learningState.currentLearningGroupIndex} freigeschaltet.`;
            }
        }

        /**
         * Clears all progress data and resets the learning state.
         */
        function clearProgress() {
            if (confirm('Möchtest du wirklich deinen gesamten Fortschritt löschen? Dies kann nicht rückgängig gemacht werden.')) {
                localStorage.removeItem('quizProgress');
                localStorage.removeItem('studyTimeSeconds');
                localStorage.removeItem('verbGroups');
                localStorage.removeItem('currentLearningGroupIndex');
                localStorage.removeItem('learningSeed');
                
                quizProgress = {};
                studyTimeSeconds = 0;
                
                // Reset learning state and reinitialize groups
                learningState = {
                    verbGroups: [],
                    currentLearningGroupIndex: 0,
                    seed: null
                };
                
                initializeVerbGroups();
                saveProgress();
                updateProgressDisplay();
                
                setupFeedbackDiv.textContent = 'Fortschritt wurde zurückgesetzt.';
                setupFeedbackDiv.className = 'text-center feedback-message feedback-info';
            }
        }

        /**
         * Changes the seed used for verb group generation.
         */
        function changeSeed() {
            const newSeed = seedInput.value.trim();
            if (newSeed === '') {
                // If empty, generate a random seed
                initializeVerbGroups(Date.now());
            } else {
                initializeVerbGroups(newSeed);
            }
            
            // Update UI
            seedInput.value = '';
            setupFeedbackDiv.textContent = 'Verbengruppen wurden mit dem neuen Seed neu generiert.';
            setupFeedbackDiv.className = 'text-center feedback-message feedback-info';
        }

        /**
         * Shows the modal with verbs in the current learning group.
         */
        function showVerbGroupInfo() {
            const currentGroupInfinitives = learningState.verbGroups[learningState.currentLearningGroupIndex] || [];
            
            // Clear and populate the verb list
            verbListUl.innerHTML = '';
            for (const infinitive of currentGroupInfinitives) {
                const li = document.createElement('li');
                li.textContent = infinitive;
                verbListUl.appendChild(li);
            }
            
            // Show the modal
            verbGroupInfoModal.classList.remove('hidden');
        }

        // --- Event Listeners ---

        // Start quiz button
        startQuizBtn.addEventListener('click', startQuiz);

        // Check answer button
        checkAnswerBtn.addEventListener('click', checkAnswer);

        // Next verb button
        nextVerbBtn.addEventListener('click', nextQuestion);

        // Clear progress button
        clearProgressBtn.addEventListener('click', clearProgress);

        // Change seed button
        changeSeedBtn.addEventListener('click', changeSeed);

        // Info icon (show verb group info)
        infoIcon.addEventListener('click', showVerbGroupInfo);

        // Close modal button
        closeVerbGroupInfoModalBtn.addEventListener('click', () => {
            verbGroupInfoModal.classList.add('hidden');
        });

        // Allow pressing Enter to check answer or go to next question
        answerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (!nextVerbBtn.classList.contains('hidden')) {
                    nextQuestion();
                } else {
                    checkAnswer();
                }
            }
        });

        // Learning mode radio buttons
        document.querySelectorAll('input[name="learningMode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const seedGroupControls = document.getElementById('seedGroupControls');
                if (this.value === 'all') {
                    seedGroupControls.classList.add('hidden');
                } else {
                    seedGroupControls.classList.remove('hidden');
                }
            });
        });

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            fetchVerbsData();
            
            // Set up initial UI state for learning mode
            const seedGroupControls = document.getElementById('seedGroupControls');
            const learningMode = document.querySelector('input[name="learningMode"]:checked').value;
            if (learningMode === 'all') {
                seedGroupControls.classList.add('hidden');
            } else {
                seedGroupControls.classList.remove('hidden');
            }
        });
    </script>
</body>
</html>
